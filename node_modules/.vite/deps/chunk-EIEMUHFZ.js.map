{
  "version": 3,
  "sources": ["../../src/.internal/core/util/Type.ts", "../../src/.internal/core/util/Array.ts", "../../src/.internal/core/util/Object.ts", "../../src/.internal/core/util/Disposer.ts", "../../src/.internal/core/util/EventDispatcher.ts", "../../src/.internal/core/util/Template.ts", "../../src/.internal/core/util/Order.ts", "../../src/.internal/core/Theme.ts"],
  "sourcesContent": ["/**\n * A collection of utility functions for various type checks and conversion\n * @hidden\n */\n\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\n\n/**\n * ============================================================================\n * MISC\n * ============================================================================\n * @hidden\n */\n\ntype Cond<T, Keys extends keyof T> = Keys extends never\n\t? never\n\t: { [K in Keys]: T[K] };\n\ntype Never<T> = T extends undefined ? never : T;\n\n/**\n * Selects all the keys of T which have a value of U.\n */\nexport type SelectKeys<T, U> = Never<{ [K in keyof T]: T[K] extends U ? K : never }[keyof T]>;\n\n/**\n * Creates a new type which is the same as T except it only has the properties of type U.\n */\nexport type Select<T, U> = Cond<T, SelectKeys<T, U>>;\n\n\n/**\n * @todo Description\n * @ignore Exclude from docs\n */\nexport type Public<T> = { [P in keyof T]: T[P] };\n\n\n/**\n * `Keyof<T>` is the same as `keyof T` except it only accepts string keys, not numbers or symbols.\n */\nexport type Keyof<T> = Extract<keyof T, string>;\n\n\n\n/**\n * ============================================================================\n * TYPE CHECK\n * ============================================================================\n * @hidden\n */\n\n/**\n * Returns `true` if value is not a number (NaN).\n *\n * @param value Input value\n * @return Is NaN?\n */\nexport function isNaN(value: number): boolean {\n\treturn Number(value) !== value;\n}\n\n/**\n * Represents a type for all available JavaScript variable types.\n */\nexport type Type\n\t= \"[object Object]\"\n\t| \"[object Array]\"\n\t| \"[object String]\"\n\t| \"[object Number]\"\n\t| \"[object Boolean]\"\n\t| \"[object Date]\";\n\n/**\n * Returns a type of the value.\n *\n * @param value  Input value\n * @return Type of the value\n * @ignore\n */\nexport function getType<A>(value: A): Type {\n\treturn ({}).toString.call(value) as Type;\n}\n\n\n/**\n * Asserts that the condition is true.\n *\n * @param condition  Condition to check\n * @param message    Message to display in the error\n * @ignore\n */\nexport function assert(condition: boolean, message: string = \"Assertion failed\"): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(message);\n\t}\n}\n\n\n/**\n * ============================================================================\n * QUICK CONVERSION\n * ============================================================================\n * @hidden\n */\n\n\n/**\n * Converts any value into a `number`.\n *\n * @param value  Source value\n * @return Number representation of value\n */\nexport function toNumber(value: any): number {\n\tif (value != null && !isNumber(value)) {\n\t\tlet converted = Number(value);\n\t\tif (isNaN(converted) && isString(value) && value != \"\" && value.match(/[0-9]+/)) {\n\t\t\treturn toNumber(value.replace(/[^0-9.\\-]+/g, ''));\n\t\t}\n\t\treturn converted;\n\t}\n\treturn value;\n}\n\n\n\n/**\n * Converts anything to Date object.\n *\n * @param value  A value of any type\n * @return Date object representing a value\n */\nexport function toDate(value: Date | number | string): Date {\n\tif (isDate(value)) {\n\t\t// TODO maybe don't create a new Date ?\n\t\treturn new Date(value);\n\t}\n\n\telse if (isNumber(value)) {\n\t\treturn new Date(value);\n\t}\n\n\telse {\n\t\t// Try converting to number (assuming timestamp)\n\t\tlet num = Number(value);\n\n\t\tif (!isNumber(num)) {\n\t\t\treturn new Date(value);\n\t\t}\n\t\telse {\n\t\t\treturn new Date(num);\n\t\t}\n\t}\n}\n\n/**\n * Converts numeric value into string. Deals with large or small numbers that\n * would otherwise use exponents.\n *\n * @param value  Numeric value\n * @return Numeric value as string\n */\nexport function numberToString(value: number): string {\n\t// TODO handle Infinity and -Infinity\n\tif (isNaN(value)) {\n\t\treturn \"NaN\";\n\t}\n\n\tif (value === Infinity) {\n\t\treturn \"Infinity\";\n\t}\n\n\tif (value === -Infinity) {\n\t\treturn \"-Infinity\";\n\t}\n\n\t// Negative 0\n\tif ((value === 0) && (1 / value === -Infinity)) {\n\t\treturn \"-0\";\n\t}\n\n\t// Preserve negative and deal with absoute values\n\tlet negative = value < 0;\n\n\tvalue = Math.abs(value);\n\n\t// TODO test this\n\tlet parsed = /^([0-9]+)(?:\\.([0-9]+))?(?:e[\\+\\-]([0-9]+))?$/.exec(\"\" + value)!;\n\tlet digits = parsed[1];\n\tlet decimals = parsed[2] || \"\";\n\n\tlet res: string;\n\n\t// Leave the nummber as it is if it does not use exponents\n\tif (parsed[3] === undefined) {\n\t\tres = (decimals === \"\" ? digits : digits + \".\" + decimals);\n\n\t} else {\n\t\tlet exponent = +parsed[3];\n\n\t\t// Deal with decimals\n\t\tif (value < 1) {\n\t\t\tlet zeros = exponent - 1;\n\n\t\t\tres = \"0.\" + repeat(\"0\", zeros) + digits + decimals;\n\n\t\t\t// Deal with integers\n\t\t} else {\n\t\t\tlet zeros = exponent - decimals.length;\n\n\t\t\tif (zeros === 0) {\n\t\t\t\tres = digits + decimals;\n\n\t\t\t} else if (zeros < 0) {\n\t\t\t\tres = digits + decimals.slice(0, zeros) + \".\" + decimals.slice(zeros);\n\n\t\t\t} else {\n\t\t\t\tres = digits + decimals + repeat(\"0\", zeros);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn negative ? \"-\" + res : res;\n}\n\n/**\n * Repeats a `string` number of times as set in `amount`.\n *\n * @ignore Exclude from docs\n * @todo Make this faster\n * @param string  Source string\n * @param amount  Number of times to repeat string\n * @return New string\n */\nexport function repeat(string: string, amount: number): string {\n  return new Array(amount + 1).join(string);\n}\n\n\n/**\n * ============================================================================\n * VALUE PRESENCE CHECK\n * ============================================================================\n * @hidden\n */\n\n/**\n * Defines an optional value that can be of any type or `undefined`.\n */\nexport type Optional<A> = A | undefined;\n\n\n/**\n * ============================================================================\n * TYPE CHECK\n * ============================================================================\n * @hidden\n */\n\n/**\n * Checks if parameter is `Date`.\n *\n * @param value  Input value\n * @return Is Date?\n */\nexport function isDate(value: any): value is Date {\n\treturn getType(value) === \"[object Date]\";\n}\n\n/**\n * Checks if parameter is `string`.\n *\n * @param value  Input value\n * @return Is string?\n */\nexport function isString(value: any): value is string {\n\treturn typeof value === \"string\";\n}\n\n/**\n * Checks if parameter is `number`.\n *\n * @param value  Input value\n * @return Is number?\n */\nexport function isNumber(value: any): value is number {\n\treturn typeof value === \"number\" && Number(value) == value;\n}\n\n/**\n * Checks if parameter is `object`.\n *\n * @param value  Input value\n * @return Is object?\n */\nexport function isObject(value: any): value is object {\n\treturn typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if parameter is `Array`.\n *\n * @param value  Input value\n * @return Is Array?\n */\nexport function isArray(value: any): value is Array<unknown> {\n\treturn Array.isArray(value);\n}\n\n\n/**\n * ============================================================================\n * STATIC CONSTANTS\n * ============================================================================\n * @hidden\n */\n\n\n/**\n * @ignore Exclude from docs\n */\nexport const PLACEHOLDER: string = \"__§§§__\";\n\n/**\n * @ignore Exclude from docs\n */\nexport const PLACEHOLDER2: string = \"__§§§§__\";\n", "/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport type { Optional } from \"./Type\";\nimport * as $type from \"./Type\";\n\n\n/**\n * ============================================================================\n * UTILITY FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Searches `array` for `value`.\n *\n * Returns -1 if not found.\n *\n * @param array  Source array\n * @param value  Value to search\n * @returns Index\n */\nexport function indexOf<A>(array: ArrayLike<A>, value: A): number {\n\tconst length = array.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\t// TODO handle NaN\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Calls `test` for each element in `array`.\n *\n * If `test` returns `true` then it immediately returns `true`.\n *\n * If `test` returns `false` for all of the elements in `array` then it returns `false`.\n *\n * @param array  Source array\n * @param test   Function which is called on each element\n * @returns Whether `test` returned true or not\n */\nexport function any<A>(array: ArrayLike<A>, test: (value: A) => boolean): boolean {\n\tconst length = array.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tif (test(array[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Calls `fn` function for every member of array and returns a new array out\n * of all outputs.\n *\n * @param array  Source array\n * @param fn     Callback function\n * @returns New array\n */\nexport function map<A, B>(array: ArrayLike<A>, fn: (value: A, index: number) => B): Array<B> {\n\tconst length = array.length;\n\tconst output = new Array(length);\n\n\tfor (let i = 0; i < length; ++i) {\n\t\toutput[i] = fn(array[i], i);\n\t}\n\n\treturn output;\n}\n\n/**\n * Iterates through all items in array and calls `fn` function for each of\n * them.\n *\n * @param array  Source array\n * @param fn     Callback function\n */\nexport function each<A>(array: ArrayLike<A>, fn: (value: A, index: number) => void): void {\n\tconst length = array.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tfn(array[i], i);\n\t}\n}\n\n/**\n * Iterates through all items in array in reverse order and calls `fn` function for each of\n * them.\n *\n * @param array  Source array\n * @param fn     Callback function\n */\nexport function eachReverse<A>(array: ArrayLike<A>, fn: (value: A, index: number) => void): void {\n\tlet i = array.length;\n\n\twhile (i > 0) {\n\t\t--i;\n\t\tfn(array[i], i);\n\t}\n}\n\n/**\n * Iterates through all items in array and calls `fn` function for each of\n * them.\n *\n * If `fn` call evaluates to `false`, further iteration is cancelled.\n *\n * @param array  Source array\n * @param fn     Callback function\n */\nexport function eachContinue<A>(array: ArrayLike<A>, fn: (value: A, index: number) => boolean): void {\n\tconst length = array.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tif (!fn(array[i], i)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Shifts an item at `index` towards beginning of the array.\n *\n * @param array  Source array\n * @param index  Target element index\n */\nexport function shiftLeft<A>(array: Array<A>, index: number): void {\n\tconst length = array.length;\n\n\tfor (let i = index; i < length; ++i) {\n\t\tarray[i - index] = array[i];\n\t}\n\n\tarray.length = length - index;\n}\n\n/**\n * Returns the last item of the array.\n *\n * @param array  Source array\n * @returns Last item\n */\nexport function last<A>(array: Array<A>): Optional<A> {\n\tconst length = array.length;\n\treturn length ? array[length - 1] : undefined;\n}\n\n/**\n * Returns the first item of the array.\n *\n * @param array  Source array\n * @returns Last item\n */\nexport function first<A>(array: Array<A>): Optional<A> {\n\treturn array[0];\n}\n\n/**\n * Inserts `element` into `array` at `index`.\n *\n * Caps `index` to be between `0` and `array.length`\n *\n * @param array    Source array\n * @param element  Item to insert\n * @param array    Index to insert item at\n */\nexport function insert<A>(array: Array<A>, element: A, index: number): void {\n\t//if (array) {\n\tindex = Math.max(0, Math.min(index, array.length));\n\tarray.splice(index, 0, element);\n\t//}\n}\n\n/**\n * Removes all copies of `element` from `array` (if they exist) and then\n * inserts `element` at `index`.\n *\n * @param array    Source array\n * @param element  Item\n * @param array    Index to move item to\n */\nexport function setIndex<A>(array: Array<A>, element: A, index: number): void {\n\tremove(array, element);\n\tinsert(array, element, index);\n}\n\n\n/**\n * Pushes all of the elements from `input` into `array`.\n *\n * @param array  Output array\n * @param input  Input array\n */\nexport function pushAll<A>(array: Array<A>, input: Array<A>) {\n\tconst length = input.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tarray.push(input[i]);\n\t}\n}\n\n\n/**\n * Removes `element` from `array`.\n *\n * If there are multiple copies of `element`, they are all removed.\n *\n * @param array    Source array\n * @param element  Item to remove\n */\nexport function remove<A>(array: Array<A>, element: A): boolean {\n\tlet found: boolean = false;\n\tlet index: number = 0;\n\n\tfor (;;) {\n\t\tindex = array.indexOf(element, index);\n\n\t\tif (index === -1) {\n\t\t\treturn found;\n\n\t\t} else {\n\t\t\tfound = true;\n\t\t\tarray.splice(index, 1);\n\t\t}\n\t}\n}\n\nexport function removeFirst<A>(array: Array<A>, element: A): boolean {\n\tlet index: number = array.indexOf(element);\n\n\tif (index !== -1) {\n\t\tarray.splice(index, 1);\n\t\treturn true;\n\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Adds an `element` to `array`.\n *\n * If array already contains and item like this, it is removed before adding\n * it again.\n *\n * Optionally `toIndex` can be specified to add element at specific index.\n *\n * @param array    Source array\n * @param element  Item to add\n * @param array    Index to move item to\n */\nexport function move<A>(array: Array<A>, element: A, toIndex?: number): void {\n\t// @todo this implementation must be the same as the List.moveValue method\n\t// @todo don't do anything if the desired index is the same as the current index\n\tlet index = indexOf(array, element);\n\n\t// @todo remove all old values rather than only the first ?\n\tif (index !== -1) {\n\t\tremoveIndex(array, index);\n\t}\n\n\tif (toIndex == null) {\n\t\tarray.push(element);\n\t} else {\n\t\tinsertIndex(array, toIndex, element);\n\t}\n}\n\n\n/**\n * Inserts `element` into `array` at `index`.\n *\n * If `index` is not provided, it will insert `element` at the end of `array`.\n *\n * @param array    Source array\n * @param element  Item to add\n * @param array    Index to add item at\n */\nexport function add<A>(array: Array<A>, element: A, index?: number): void {\n\t// Append to the end if index is not set\n\tif (!$type.isNumber(index)) {\n\t\tarray.push(element);\n\t}\n\n\t// Add to the beginning of array if index is 0\n\telse if (index === 0) {\n\t\tarray.unshift(element);\n\t}\n\t// Add to indicated place if index is set\n\telse {\n\t\tarray.splice(index, 0, element);\n\t}\n}\n\n\n/**\n * Pushes `element` into `array` if it doesn't already exist.\n *\n * @param array    Source array\n * @param element  Item to add\n */\nexport function pushOne<A>(array: Array<A>, element: A): void {\n\tif (array.indexOf(element) === -1) {\n\t\tarray.push(element);\n\t}\n}\n\n\n/**\n * Removes `element` from `array` (if it exists) and then inserts `element` at\n * `index`.\n *\n * If `index` is not provided, it will insert `element` at the end of `array`.\n *\n * @param array    Source array\n * @param element  Item to remove\n * @param array    Index to move item to\n */\nexport function replace<A>(array: Array<A>, element: A, index?: number): void {\n\t// check if exists\n\tlet ind: number = array.indexOf(element);\n\n\t// remove if exists\n\tif (ind !== -1) {\n\t\tarray.splice(ind, 1);\n\t}\n\n\t// add to end if index is not set\n\tif (!$type.isNumber(index)) {\n\t\tarray.push(element);\n\t}\n\t// add to indicated place if index is set\n\telse {\n\t\tarray.splice(index, 0, element);\n\t}\n}\n\n/**\n * Wraps `input` in an array, if it isn't already an array.\n *\n * @param input  Source value\n * @return An array\n */\nexport function toArray<A>(input: Array<A> | A): Array<A> {\n\tif (Array.isArray(input)) {\n\t\treturn input;\n\t}\n\telse {\n\t\treturn [input];\n\t}\n}\n\n/**\n * Returns `true` if `element` exists in `array`.\n *\n * @param array    Source array\n * @param element  Item to search for\n * @returns Item in array?\n */\nexport function has<A>(array: ArrayLike<A>, element: A): boolean {\n\treturn indexOf(array, element) !== -1;\n}\n\n/**\n * Returns a shallow copy of `array`.\n *\n * @param array  Source array\n * @returns Copy of the array\n */\nexport function copy<A>(array: ArrayLike<A>): Array<A> {\n\tconst length = array.length;\n\n\t// It's faster to create the array with a pre-defined length\n\tconst output = new Array(length);\n\n\tfor (let i = 0; i < length; ++i) {\n\t\t// Because the array has a pre-defined length, we have to assign rather than push\n\t\t// This is also faster than pushing\n\t\toutput[i] = array[i];\n\t}\n\n\treturn output;\n}\n\n\n/**\n * Returns a copy of `array` which contains all the elements between `start`\n * and `end`. (including `start` and excluding `end`)\n *\n * If `end` is not provided, it defaults to `array.length`.\n *\n * @param array  Source array\n * @param start  Start index\n * @param end    End index\n * @returns Part of the array\n */\nexport function slice<A>(array: ArrayLike<A>, start: number, end: number = array.length): Array<A> {\n\tconst output = new Array(end - start);\n\n\tfor (let i = start; i < end; ++i) {\n\t\toutput[i - start] = array[i];\n\t}\n\n\treturn output;\n}\n\n/**\n * Inserts a value into array at specific index.\n *\n * @param array  Source array\n * @param index  Index\n * @param value  Value to insert\n */\nexport function insertIndex<A>(array: Array<A>, index: number, value: A): void {\n\tarray.splice(index, 0, value);\n}\n\n/**\n * Removes a value from array at specific index.\n *\n * @param array  Source array\n * @param index  Index\n */\nexport function removeIndex<A>(array: Array<A>, index: number): void {\n\tarray.splice(index, 1);\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface SortResult {\n\tfound: boolean;\n\tindex: number\n}\n\n/**\n * Searches the array using custom function and returns index of the item if\n * found.\n *\n * Will call `matches` function on all items of the array. If return value\n * evaluates to `true`, index is returned.\n *\n * Otherwise returns -1.\n *\n * @param array    Source array\n * @param matches  Search function\n * @returns Index of the item if found\n */\nexport function findIndex<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): number {\n\tconst length = array.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tif (matches(array[i], i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * This is the same as `findIndex` except it searches from right to left.\n *\n * @param array    Source array\n * @param matches  Search function\n * @returns Index of the item if found\n */\nexport function findIndexReverse<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): number {\n\tlet i = array.length;\n\n\twhile (i > 0) {\n\t\t--i;\n\t\tif (matches(array[i], i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Searches the array using custom function and returns item if found.\n *\n * Will call `matches` function on all items of the array. If return value\n * evaluates to `true`, index is returned.\n *\n * Otherwise returns `undefined`.\n *\n * @param array    Source array\n * @param matches  Search function\n * @returns Item if found\n */\nexport function find<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): A | undefined {\n\tconst index = findIndex(array, matches);\n\n\tif (index !== -1) {\n\t\treturn array[index];\n\t}\n}\n\n/**\n * This is the same as `find` except it searches from right to left.\n *\n * @param array    Source array\n * @param matches  Search function\n * @returns Item if found\n */\nexport function findReverse<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): A | undefined {\n\tconst index = findIndexReverse(array, matches);\n\n\tif (index !== -1) {\n\t\treturn array[index];\n\t}\n}\n\n/**\n * Searches the array using custom function and returns item if found.\n *\n * Will call `matches` function on all items of the array. If value\n * is not `undefined`, it returns it.\n *\n * Otherwise returns `undefined`.\n *\n * @param array    Source array\n * @param matches  Search function\n * @returns Item if found\n */\nexport function findMap<A, B>(array: ArrayLike<A>, matches: (value: A, index: number) => B | undefined): B | undefined {\n\tconst length = array.length;\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tconst value = matches(array[i], i);\n\n\t\tif (value !== undefined) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * Iterates through all items in array and calls `fn` function for each of\n * them.\n *\n * @param array  Source array\n * @param fn     Callback function\n */\nexport function shuffle<A>(array: Array<A>) {\n\t// https://stackoverflow.com/a/2450976/449477\n\tlet currentIndex = array.length,\n\t\ttemporaryValue,\n\t\trandomIndex;\n\n\t// While there remain elements to shuffle...\n\twhile (0 !== currentIndex) {\n\t\t// Pick a remaining element...\n\t\trandomIndex = Math.floor(Math.random() * currentIndex);\n\t\tcurrentIndex -= 1;\n\n\t\t// And swap it with the current element.\n\t\ttemporaryValue = array[currentIndex];\n\t\tarray[currentIndex] = array[randomIndex];\n\t\tarray[randomIndex] = temporaryValue;\n\t}\n}\n\n\nexport type Ordering = -1 | 0 | 1;\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface SortResult {\n\tfound: boolean;\n\tindex: number\n}\n\n/**\n * Orders an array using specific `ordering` function and returns right-most index of\n * the `value`.\n *\n * @ignore Exclude from docs\n * @param array     Source array\n * @param ordering  An ordering function\n * @returns Result of the search\n */\nexport function getSortedIndex<A>(array: ArrayLike<A>, ordering: (left: A) => Ordering): SortResult {\n\tlet start = 0;\n\tlet end   = array.length;\n\tlet found = false;\n\n\twhile (start < end) {\n\t\t// TODO is this faster/slower than using Math.floor ?\n\t\tconst pivot = (start + end) >> 1;\n\n\t\tconst order = ordering(array[pivot]);\n\n\t\t// less\n\t\tif (order < 0) {\n\t\t\tstart = pivot + 1;\n\n\t\t// equal\n\t\t} else if (order === 0) {\n\t\t\tfound = true;\n\t\t\tstart = pivot + 1;\n\n\t\t// more\n\t\t} else {\n\t\t\tend = pivot;\n\t\t}\n\t}\n\n\treturn {\n\t\tfound: found,\n\t\tindex: (found ? start - 1 : start)\n\t};\n}\n\n\n/**\n * Orders an array using specific `ordering` function and returns left-most index of\n * the `value`.\n *\n * @ignore Exclude from docs\n * @param array     Source array\n * @param ordering  An ordering function\n * @returns Result of the search\n */\nexport function getFirstSortedIndex<A>(array: ArrayLike<A>, ordering: (left: A) => Ordering): SortResult {\n\tlet start = 0;\n\tlet end   = array.length;\n\tlet found = false;\n\n\twhile (start < end) {\n\t\t// TODO is this faster/slower than using Math.floor ?\n\t\tconst pivot = (start + end) >> 1;\n\n\t\tconst order = ordering(array[pivot]);\n\n\t\t// less\n\t\tif (order < 0) {\n\t\t\tstart = pivot + 1;\n\n\t\t// equal\n\t\t} else if (order === 0) {\n\t\t\tfound = true;\n\t\t\tend = pivot;\n\n\t\t// more\n\t\t} else {\n\t\t\tend = pivot;\n\t\t}\n\t}\n\n\treturn {\n\t\tfound: found,\n\t\tindex: start\n\t};\n}\n\n\nexport function keepIf<A>(array: Array<A>, keep: (value: A) => boolean): void {\n\tlet i = array.length;\n\n\twhile (i > 0) {\n\t\t--i;\n\n\t\tif (!keep(array[i])) {\n\t\t\tarray.splice(i, 1);\n\t\t}\n\t}\n}\n", "import * as $array from \"./Array\";\nimport type { Keyof } from \"./Type\";\n\nexport function keys<O>(object: O): Array<Keyof<O>> {\n\treturn Object.keys(object) as Array<Keyof<O>>;\n}\n\n/**\n * Returns an array of object's property names ordered using specific ordering\n * function.\n *\n * @param object  Source object\n * @param order   Ordering function\n * @returns Object property names\n */\nexport function keysOrdered<Object>(object: Object, order: (a: Keyof<Object>, b: Keyof<Object>) => number): Array<Keyof<Object>> {\n\treturn keys(object).sort(order);\n}\n\nexport function copy<O>(object: O): O {\n\treturn Object.assign({}, object);\n}\n\nexport function each<O>(object: O, f: <K extends keyof O>(key: K, value: Exclude<O[K], undefined>) => void): void {\n\tkeys(object).forEach((key) => {\n\t\tf(key, object[key] as any);\n\t});\n}\n\n/**\n * Iterates through all properties of the object calling `fn` for each of them.\n *\n * If return value of the function evaluates to `false` further iteration is\n * cancelled.\n *\n * @param object  Source object\n * @param fn      Callback function\n */\nexport function eachContinue<Object>(object: Object, fn: <Key extends Keyof<Object>>(key: Key, value: Object[Key]) => boolean): void {\n\tfor (let key in object) {\n\t\tif (hasKey(object, key)) {\n\t\t\tif (!fn(key as Keyof<Object>, object[key] as Object[Keyof<Object>])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Orders object properties using custom `ord` function and iterates through\n * them calling `fn` for each of them.\n *\n * @param object  Source object\n * @param fn      Callback function\n * @param order   Ordering function\n */\nexport function eachOrdered<Object>(object: Object, fn: <Key extends Keyof<Object>>(key: Key, value: Object[Key]) => void, ord: (a: Keyof<Object>, b: Keyof<Object>) => number): void {\n\t$array.each(keysOrdered(object, ord), (key) => {\n\t\tfn(key, object[key]);\n\t});\n}\n\n/**\n * Checks if `object` has a specific `key`.\n *\n * @param object  Source object\n * @param key     Property name\n * @returns Has key?\n */\nexport function hasKey<Object, Key extends keyof Object>(object: Object, key: Key): boolean {\n\treturn {}.hasOwnProperty.call(object, key);\n}\n\n/**\n * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.\n *\n * @param fromObject  Source object\n * @param toObject    Target object\n * @return Updated target object\n * @todo Maybe consolidate with utils.copy?\n */\nexport function softCopyProperties(source: Object, target: Object): Object {\n\teach(source, (key, value) => {\n\t\t// only if value is set\n\t\t//if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {\n\t\tif (value != null && (<any>target)[key] == null) {\n\t\t\t(<any>target)[key] = value;\n\t\t}\n\t});\n\treturn target;\n}\n", "/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport * as $array from \"./Array\";\nimport type { Optional } from \"./Type\";\n\n/**\n * Defines interface for disposable objects.\n *\n * @ignore Exclude from docs\n */\nexport interface IDisposer {\n\tisDisposed(): boolean;\n\tdispose(): void;\n}\n\n/**\n * A base class for disposable objects.\n *\n * @ignore Exclude from docs\n */\nexport abstract class DisposerClass implements IDisposer {\n\n\t/**\n\t * Is object disposed?\n\t */\n\tprivate _disposed: boolean;\n\n\t/**\n\t * Constructor.\n\t */\n\tconstructor() {\n\t\tthis._disposed = false;\n\t}\n\n\t/**\n\t * Checks if object is disposed.\n\t *\n\t * @return Disposed?\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\tprotected abstract _dispose(): void;\n\n\t/**\n\t * Disposes the object.\n\t */\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\t\t\tthis._dispose();\n\t\t}\n\t}\n}\n\n/**\n * A class for creating an IDisposer.\n *\n * @ignore Exclude from docs\n */\nexport class Disposer implements IDisposer {\n\n\t/**\n\t * Is object disposed?\n\t */\n\tprivate _disposed: boolean;\n\n\t/**\n\t * Method that disposes the object.\n\t */\n\tprivate _dispose: () => void;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param dispose  Function that disposes object\n\t */\n\tconstructor(dispose: () => void) {\n\t\tthis._disposed = false;\n\t\tthis._dispose = dispose;\n\t}\n\n\t/**\n\t * Checks if object is disposed.\n\t *\n\t * @return Disposed?\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Disposes the object.\n\t */\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\t\t\tthis._dispose();\n\t\t}\n\t}\n}\n\n/**\n * This can be extended by other classes to add a `_disposers` property.\n *\n * @ignore Exclude from docs\n */\nexport class ArrayDisposer extends DisposerClass {\n\tprotected _disposers: Array<IDisposer> = [];\n\n\tprotected _dispose(): void {\n\t\t$array.each(this._disposers, (x) => {\n\t\t\tx.dispose();\n\t\t});\n\t}\n}\n\n/**\n * A collection of related disposers that can be disposed in one go.\n *\n * @ignore Exclude from docs\n */\nexport class MultiDisposer extends DisposerClass {\n\tprotected _disposers: Array<IDisposer>;\n\n\tconstructor(disposers: Array<IDisposer>) {\n\t\tsuper();\n\t\tthis._disposers = disposers;\n\t}\n\n\tprotected _dispose(): void {\n\t\t$array.each(this._disposers, (x) => {\n\t\t\tx.dispose();\n\t\t});\n\t}\n\n\tpublic get disposers(): Array<IDisposer> {\n\t\treturn this._disposers;\n\t}\n}\n\n/**\n * A special kind of Disposer that has attached value set.\n *\n * If a new value is set using `set()` method, the old disposer value is\n * disposed.\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class MutableValueDisposer<T extends IDisposer> extends DisposerClass {\n\n\t/**\n\t * Current disposer.\n\t */\n\tprivate _disposer: Optional<IDisposer>;\n\n\t/**\n\t * Current value.\n\t */\n\tprivate _value: Optional<T>;\n\n\tprotected _dispose(): void {\n\t\tif (this._disposer != null) {\n\t\t\tthis._disposer.dispose();\n\t\t\tthis._disposer = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns current value.\n\t *\n\t * @return Value\n\t */\n\tpublic get(): Optional<T> {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Sets value and disposes previous disposer if it was set.\n\t *\n\t * @param value     New value\n\t * @param disposer  Disposer\n\t */\n\tpublic set(value: Optional<T>, disposer: Optional<IDisposer>): void {\n\t\tif (this._disposer != null) {\n\t\t\tthis._disposer.dispose();\n\t\t}\n\n\t\tthis._disposer = disposer;\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the disposer value.\n\t */\n\tpublic reset(): void {\n\t\tthis.set(undefined, undefined);\n\t}\n\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class CounterDisposer extends Disposer {\n\n\t/**\n\t * [_counter description]\n\t *\n\t * @todo Description\n\t */\n\tprivate _counter: number = 0;\n\n\t/**\n\t * [increment description]\n\t *\n\t * @todo Description\n\t */\n\tpublic increment() {\n\t\t// TODO throw an error if it is disposed\n\t\t++this._counter;\n\n\t\t// TODO make this more efficient\n\t\treturn new Disposer(() => {\n\t\t\t--this._counter;\n\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n}\n", "/**\n * Event Dispatcher module is used for registering listeners and dispatching\n * events across amCharts system.\n */\n\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { Disposer, IDisposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n\n/**\n * @ignore\n */\nexport type Events<Target, T> = {\n\t[K in keyof T]: T[K] & { type: K, target: Target }\n};\n\n/**\n * A universal interface for event listeners.\n *\n * @ignore\n */\nexport interface EventListener {\n\tkilled: boolean;\n\tonce: boolean;\n\ttype: any | null;\n\tcallback: (event: any) => void;\n\tcontext: unknown;\n\tshouldClone: boolean;\n\tdispatch: (type: any, event: any) => void;\n\tdisposer: IDisposer;\n}\n\n/**\n * Universal Event Dispatcher.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\n */\nexport class EventDispatcher<T> implements IDisposer {\n\tprotected _listeners: Array<EventListener>;\n\tprotected _killed: Array<EventListener>;\n\tprotected _disabled: { [key in keyof T]?: number };\n\tprotected _iterating: number;\n\tprotected _enabled: boolean;\n\tprotected _disposed: boolean;\n\n\n\t/**\n\t * Constructor\n\t */\n\tconstructor() {\n\t\tthis._listeners = [];\n\t\tthis._killed = [];\n\t\tthis._disabled = {};\n\t\tthis._iterating = 0;\n\t\tthis._enabled = true;\n\t\tthis._disposed = false;\n\t}\n\n\t/**\n\t * Returns if this object has been already disposed.\n\t *\n\t * @return Disposed?\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Dispose (destroy) this object.\n\t */\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\tconst a = this._listeners;\n\n\t\t\tthis._iterating = 1;\n\t\t\tthis._listeners = <any>null;\n\t\t\tthis._disabled = <any>null;\n\n\t\t\ttry {\n\t\t\t\t$array.each(a, (x) => {\n\t\t\t\t\tx.disposer.dispose();\n\t\t\t\t});\n\n\t\t\t} finally {\n\t\t\t\tthis._killed = <any>null;\n\t\t\t\tthis._iterating = <any>null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any listeners set.\n\t *\n\t * @return Has listeners?\n\t */\n\tpublic hasListeners(): boolean {\n\t\treturn this._listeners.length !== 0;\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any particular listeners set.\n\t *\n\t * @return Has particular event listeners?\n\t */\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\n\t}\n\n\t/**\n\t * Enable dispatching of events if they were previously disabled by\n\t * `disable()`.\n\t */\n\tpublic enable(): void {\n\t\tthis._enabled = true;\n\t}\n\n\t/**\n\t * Disable dispatching of events until re-enabled by `enable()`.\n\t */\n\tpublic disable(): void {\n\t\tthis._enabled = false;\n\t}\n\n\t/**\n\t * Enable dispatching particular event, if it was disabled before by\n\t * `disableType()`.\n\t *\n\t * @param type Event type\n\t */\n\tpublic enableType<Key extends keyof T>(type: Key): void {\n\t\tdelete this._disabled[type];\n\t}\n\n\t/**\n\t * Disable dispatching of events for a certain event type.\n\t *\n\t * Optionally, can set how many dispatches to skip before automatically\n\t * re-enabling the dispatching.\n\t *\n\t * @param type    Event type\n\t * @param amount  Number of event dispatches to skip\n\t */\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\n\t\tthis._disabled[type] = amount;\n\t}\n\n\t/**\n\t * Removes listener from dispatcher.\n\t *\n\t * Will throw an exception if such listener does not exists.\n\t *\n\t * @param listener Listener to remove\n\t */\n\tprotected _removeListener(listener: EventListener): void {\n\t\tif (this._iterating === 0) {\n\t\t\tconst index = this._listeners.indexOf(listener);\n\n\t\t\tif (index === -1) {\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\n\t\t\t}\n\n\t\t\tthis._listeners.splice(index, 1);\n\n\t\t} else {\n\t\t\tthis._killed.push(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Removes existing listener by certain parameters.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tprotected _removeExistingListener<C, Key extends keyof T>(once: boolean, type: Key | null, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.once === once && // TODO is this correct ?\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if dispatching for particular event type is enabled.\n\t *\n\t * @param type  Event type\n\t * @return Enabled?\n\t */\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\t// TODO is this check correct ?\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n\t}\n\n\t/**\n\t * Removes all listeners of a particular event type\n\t *\n\t * @param type  Listener's type\n\t */\n\tpublic removeType<Key extends keyof T>(type: Key): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.type === type) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if there's already a listener with specific parameters.\n\t *\n\t * @param type      Listener's type\n\t * @param callback  Callback function\n\t * @param context   Callback context\n\t * @return Has listener?\n\t */\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context;\n\t\t});\n\n\t\treturn index !== -1;\n\t}\n\n\t/**\n\t * Checks whether event of the particular type should be dispatched.\n\t *\n\t * @param type  Event type\n\t * @return Dispatch?\n\t */\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tconst count = this._disabled[type];\n\n\t\tif (!$type.isNumber(count)) {\n\t\t\treturn this._enabled;\n\n\t\t} else {\n\t\t\tif (count <= 1) {\n\t\t\t\tdelete this._disabled[type];\n\n\t\t\t} else {\n\t\t\t\t--this._disabled[type]!;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * [_eachListener description]\n\t *\n\t * All of this extra code is needed when a listener is removed while iterating\n\t *\n\t * @todo Description\n\t * @param fn [description]\n\t */\n\tprotected _eachListener(fn: (listener: EventListener) => void): void {\n\t\t++this._iterating;\n\n\t\ttry {\n\t\t\t$array.each(this._listeners, fn);\n\n\t\t} finally {\n\t\t\t--this._iterating;\n\n\t\t\t// TODO should this be inside or outside the finally ?\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\n\t\t\t\t// Remove killed listeners\n\t\t\t\t$array.each(this._killed, (killed) => {\n\t\t\t\t\tthis._removeListener(killed);\n\t\t\t\t});\n\n\t\t\t\tthis._killed.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Dispatches an event immediately without waiting for next cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Shelves the event to be dispatched within next update cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\t/*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\n\t\t\t\t\t$async.whenIdle(() => {\n\t\t\t\t\t\tif (!listener.killed) {\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}*/\n\n\t/**\n\t * Creates, catalogs and returns an [[EventListener]].\n\t *\n\t * Event listener can be disposed.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @param dispatch\n\t * @returns An event listener\n\t */\n\tprotected _on<C, Key extends keyof T>(once: boolean, type: Key | null, callback: any, context: C, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._removeExistingListener(once, type, callback, context);\n\n\t\tconst info: EventListener = {\n\t\t\ttype: type,\n\t\t\tcallback: callback,\n\t\t\tcontext: context,\n\t\t\tshouldClone: shouldClone,\n\t\t\tdispatch: <any>dispatch,\n\t\t\tkilled: false,\n\t\t\tonce: once,\n\t\t\tdisposer: new Disposer(() => {\n\t\t\t\tinfo.killed = true;\n\t\t\t\tthis._removeListener(info);\n\t\t\t})\n\t\t};\n\n\t\tthis._listeners.push(info);\n\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on **any** event.\n\t *\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic onAll<C, K extends keyof T>(callback: (this: C, event: T[K]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, null, callback, context, shouldClone, (_type, event) => (<any>callback).call(context, event as any)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler whenever series we put\n\t * event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type once.\n\t *\n\t * Once the event listener is invoked, it is automatically disposed.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler the first time series we\n\t * put event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (_type, event) => {\n\t\t\tx.disposer.dispose();\n\t\t\tcallback.call(context, event)\n\t\t});\n\n\t\t// TODO maybe this should return a different Disposer ?\n\t\treturn x.disposer;\n\t}\n\n\t/**\n\t * Removes the event listener with specific parameters.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tthis._removeExistingListener(false, type, callback, context);\n\t}\n\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n\n/**\n * A version of the [[EventDispatcher]] that dispatches events for a specific\n * target object.\n *\n * @ignore\n */\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\n\n\t/**\n\t * A target object which is originating events using this dispatcher.\n\t */\n\tpublic target: Target;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param target Event dispatcher target\n\t */\n\tconstructor(target: Target) {\n\t\tsuper();\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO very hacky\n\t\t\tif (x.context === source.target) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n", "import type { Entity, Dirty } from \"./Entity\";\nimport type { State } from \"./States\";\nimport { EventDispatcher, Events } from \"./EventDispatcher\";\nimport { IDisposer, Disposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $object from \"./Object\";\nimport * as $type from \"./Type\";\n\n\nfunction disposeSettings(settings: object) {\n\t$object.each(settings, (_key, value) => {\n\t\tif ($type.isObject(value) && typeof (value as any).dispose === \"function\") {\n\t\t\t(value as any).enableDispose = true;\n\t\t\t(value as any).dispose();\n\t\t}\n\t});\n}\n\n\nexport class TemplateState<E extends Entity> {\n\tpublic _settings: Partial<E[\"_settings\"]>;\n\n\tprivate _name: string;\n\tprivate _template: Template<E>;\n\n\tconstructor(name: string, template: Template<E>, settings: Partial<E[\"_settings\"]>) {\n\t\tthis._name = name;\n\t\tthis._template = template;\n\t\tthis._settings = settings;\n\t}\n\n\tpublic _dispose() {\n\t\tdisposeSettings(this._settings);\n\t}\n\n\tpublic get<Key extends keyof this[\"_settings\"]>(key: Key): this[\"_settings\"][Key];\n\tpublic get<Key extends keyof this[\"_settings\"], F>(key: Key, fallback: F): NonNullable<this[\"_settings\"][Key]> | F;\n\tpublic get<Key extends keyof this[\"_settings\"]>(key: Key, fallback?: any): any {\n\t\tconst value = this._settings[key];\n\n\t\tif (value !== undefined) {\n\t\t\treturn value;\n\n\t\t} else {\n\t\t\treturn fallback;\n\t\t}\n\t}\n\n\tpublic set<Key extends keyof E[\"_settings\"]>(key: Key, value: E[\"_settings\"][Key]) {\n\t\tthis._settings[key] = value;\n\t\t// TODO maybe only do this if the value changed ?\n\t\tthis._template._stateChanged(this._name);\n\t}\n\n\tpublic remove<Key extends keyof this[\"_settings\"]>(key: Key) {\n\t\tdelete this._settings[key];\n\t\t// TODO maybe only do this if the value changed ?\n\t\tthis._template._stateChanged(this._name);\n\t}\n\n\tpublic setAll(settings: this[\"_settings\"]) {\n\t\t$object.keys(settings).forEach((key) => {\n\t\t\tthis._settings[key] = settings[key];\n\t\t});\n\n\t\tthis._template._stateChanged(this._name);\n\t}\n\n\tpublic _apply(other: State<E>, seen: Dirty<E[\"_settings\"]>): void {\n\t\t$object.each(this._settings, (key, value) => {\n\t\t\tif (!seen[key] && !other._userSettings[key]) {\n\t\t\t\tseen[key] = true;\n\t\t\t\tother.setRaw(key, value);\n\t\t\t}\n\t\t});\n\t}\n}\n\n\nexport class TemplateStates<E extends Entity> {\n\tprivate _template: Template<E>;\n\tprivate _states: { [key: string]: TemplateState<E> } = {};\n\n\tconstructor(template: Template<E>) {\n\t\tthis._template = template;\n\t}\n\n\tpublic _dispose() {\n\t\t$object.each(this._states, (_key, state) => {\n\t\t\tstate._dispose();\n\t\t});\n\t}\n\n\tpublic lookup(name: string): TemplateState<E> | undefined {\n\t\treturn this._states[name];\n\t}\n\n\tpublic create(name: string, settings: Partial<E[\"_settings\"]>): TemplateState<E> {\n\t\tconst state = this._states[name];\n\n\t\tif (state) {\n\t\t\tstate.setAll(settings);\n\t\t\treturn state;\n\n\t\t} else {\n\t\t\tconst state = new TemplateState(name, this._template, settings);\n\t\t\tthis._states[name] = state;\n\t\t\tthis._template._stateChanged(name);\n\t\t\treturn state;\n\t\t}\n\t}\n\n\tpublic remove(name: string) {\n\t\tdelete this._states[name];\n\t\tthis._template._stateChanged(name);\n\t}\n\n\tpublic _apply(entity: E, state: ApplyState<E>): void {\n\t\t$object.each(this._states, (key, value) => {\n\t\t\tlet seen = state.states[key];\n\n\t\t\tif (seen == null) {\n\t\t\t\tseen = state.states[key] = {};\n\t\t\t}\n\n\t\t\tconst other = entity.states.create(key as string, {});\n\t\t\tvalue._apply(other, seen);\n\t\t});\n\t}\n}\n\n\nexport class TemplateAdapters<E extends Entity> {\n\tprivate _callbacks: { [K in keyof E[\"_settings\"]]?: Array<<O extends E>(value: O[\"_settings\"][K], target: O, key: K) => O[\"_settings\"][K]> } = {};\n\n\tpublic add<Key extends keyof E[\"_settings\"]>(key: Key, callback: (value: E[\"_settings\"][Key], target: E, key: Key) => E[\"_settings\"][Key]): IDisposer {\n\t\tlet callbacks = this._callbacks[key];\n\n\t\tif (callbacks === undefined) {\n\t\t\tcallbacks = this._callbacks[key] = [];\n\t\t}\n\n\t\tcallbacks.push(callback);\n\n\t\treturn new Disposer(() => {\n\t\t\t$array.removeFirst(callbacks!, callback);\n\n\t\t\tif (callbacks!.length === 0) {\n\t\t\t\tdelete this._callbacks[key];\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic remove<Key extends keyof E[\"_settings\"]>(key: Key) {\n\t\tconst callbacks = this._callbacks[key];\n\n\t\tif (callbacks !== undefined) {\n\t\t\tdelete this._callbacks[key];\n\t\t}\n\t}\n\n\tpublic _apply(entity: E): IDisposer {\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$object.each(this._callbacks, (key, callbacks) => {\n\t\t\t$array.each(callbacks, (callback) => {\n\t\t\t\tdisposers.push(entity.adapters.add(key, callback));\n\t\t\t});\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n}\n\n\nexport interface ApplyState<E extends Entity> {\n\tsettings: Dirty<E[\"_settings\"]>;\n\tprivateSettings: Dirty<E[\"_privateSettings\"]>;\n\tstates: { [name: string]: Dirty<E[\"_settings\"]> };\n}\n\n\n// TODO maybe extend from Properties ?\nexport class Template<E extends Entity> implements IDisposer {\n\tprivate _disposed: boolean = false;\n\n\tpublic _settings: Partial<E[\"_settings\"]>;\n\tpublic _privateSettings: E[\"_privateSettings\"] = {};\n\n\t// TODO code duplication with Properties\n\tpublic _settingEvents: { [K in keyof this[\"_settings\"]]?: Array<<V extends this[\"_settings\"][K]>(value: V) => void> } = {};\n\tpublic _privateSettingEvents: { [K in keyof this[\"_settings\"]]?: Array<<V extends this[\"_settings\"][K]>(value: V) => void> } = {};\n\n\tpublic _entities: Array<E> = [];\n\n\tpublic readonly states: TemplateStates<E> = new TemplateStates(this);\n\n\tpublic readonly adapters: TemplateAdapters<E> = new TemplateAdapters();\n\tpublic readonly events: EventDispatcher<Events<E, E[\"_events\"]>> = new EventDispatcher();\n\n\tpublic setup: (<O extends E>(entity: O) => void) | undefined;\n\n\t/**\n\t * Use this method to create an instance of this class.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\n\t * @param   root      Root element\n\t * @param   settings  Settings\n\t * @param   template  Template\n\t * @return            Instantiated object\n\t */\n\tpublic static new<E extends Entity>(settings: E[\"_settings\"]): Template<E> {\n\t\treturn new Template<E>(settings, true);\n\t}\n\n\tprotected _dispose() {\n\t\tdisposeSettings(this._settings);\n\t\tdisposeSettings(this._privateSettings);\n\t}\n\n\t/**\n\t * Returns `true` if this element is disposed.\n\t *\n\t * @return Disposed\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Disposes this object.\n\t */\n\tpublic dispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\t\t\tthis._dispose();\n\t\t}\n\t}\n\n\tprivate _checkDisposed() {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"Template is disposed\");\n\t\t}\n\t}\n\n\t/**\n\t * Array of all entities using this template.\n\t */\n\tpublic get entities():Array<E>{\n\t\treturn this._entities;\n\t}\n\n\tconstructor(settings: E[\"_settings\"], isReal: boolean) {\n\t\tif (!isReal) {\n\t\t\tthrow new Error(\"You cannot use `new Class()`, instead use `Class.new()`\");\n\t\t}\n\n\t\tthis._settings = settings;\n\t}\n\n\tpublic get<Key extends keyof this[\"_settings\"]>(key: Key): this[\"_settings\"][Key];\n\tpublic get<Key extends keyof this[\"_settings\"], F>(key: Key, fallback: F): NonNullable<this[\"_settings\"][Key]> | F;\n\tpublic get<Key extends keyof this[\"_settings\"]>(key: Key, fallback?: any): any {\n\t\tthis._checkDisposed();\n\n\t\tconst value = this._settings[key];\n\n\t\tif (value !== undefined) {\n\t\t\treturn value;\n\n\t\t} else {\n\t\t\treturn fallback;\n\t\t}\n\t}\n\n\tpublic setRaw<Key extends keyof this[\"_settings\"]>(key: Key, value: this[\"_settings\"][Key]) {\n\t\tthis._checkDisposed();\n\t\tthis._settings[key] = value;\n\t}\n\n\tpublic set<Key extends keyof this[\"_settings\"]>(key: Key, value: this[\"_settings\"][Key]) {\n\t\tthis._checkDisposed();\n\n\t\tif (this._settings[key] !== value) {\n\t\t\tthis.setRaw(key, value);\n\n\t\t\tthis._entities.forEach((entity) => {\n\t\t\t\tentity._setTemplateProperty(this, key, value);\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic remove<Key extends keyof this[\"_settings\"]>(key: Key): void {\n\t\tthis._checkDisposed();\n\n\t\tif (key in this._settings) {\n\t\t\tdelete this._settings[key];\n\n\t\t\tthis._entities.forEach((entity) => {\n\t\t\t\tentity._removeTemplateProperty(key);\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic removeAll(): void {\n\t\tthis._checkDisposed();\n\n\t\t$object.each(this._settings, (key, _value) => {\n\t\t\tthis.remove(key);\n\t\t});\n\t}\n\n\tpublic getPrivate<Key extends keyof this[\"_privateSettings\"], F>(key: Key, fallback: F): NonNullable<this[\"_privateSettings\"][Key]> | F;\n\tpublic getPrivate<Key extends keyof this[\"_privateSettings\"]>(key: Key): this[\"_privateSettings\"][Key];\n\tpublic getPrivate<Key extends keyof this[\"_privateSettings\"]>(key: Key, fallback?: any): any {\n\t\tthis._checkDisposed();\n\n\t\tconst value = this._privateSettings[key];\n\n\t\tif (value !== undefined) {\n\t\t\treturn value;\n\n\t\t} else {\n\t\t\treturn fallback;\n\t\t}\n\t}\n\n\tpublic setPrivateRaw<Key extends keyof this[\"_privateSettings\"], Value extends this[\"_privateSettings\"][Key]>(key: Key, value: Value): Value {\n\t\tthis._checkDisposed();\n\t\tthis._privateSettings[key] = value;\n\t\treturn value;\n\t}\n\n\tpublic setPrivate<Key extends keyof this[\"_privateSettings\"], Value extends this[\"_privateSettings\"][Key]>(key: Key, value: Value): Value {\n\t\tthis._checkDisposed();\n\n\t\tif (this._privateSettings[key] !== value) {\n\t\t\tthis.setPrivateRaw(key, value);\n\n\t\t\tthis._entities.forEach((entity) => {\n\t\t\t\tentity._setTemplatePrivateProperty(this, key, value);\n\t\t\t});\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tpublic removePrivate<Key extends keyof this[\"_privateSettings\"]>(key: Key): void {\n\t\tthis._checkDisposed();\n\n\t\tif (key in this._privateSettings) {\n\t\t\tdelete this._privateSettings[key];\n\n\t\t\tthis._entities.forEach((entity) => {\n\t\t\t\tentity._removeTemplatePrivateProperty(key);\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic setAll(value: this[\"_settings\"]) {\n\t\tthis._checkDisposed();\n\n\t\t$object.each(value, (key, value) => {\n\t\t\tthis.set(key, value);\n\t\t});\n\t}\n\n\t// TODO code duplication with Properties\n\tpublic on<Key extends keyof this[\"_settings\"]>(key: Key, callback: (value: this[\"_settings\"][Key], target?: E, key?: Key) => void): IDisposer {\n\t\tthis._checkDisposed();\n\n\t\tlet events = this._settingEvents[key];\n\n\t\tif (events === undefined) {\n\t\t\tevents = this._settingEvents[key] = [];\n\t\t}\n\n\t\tevents.push(callback);\n\n\t\treturn new Disposer(() => {\n\t\t\t$array.removeFirst(events!, callback);\n\n\t\t\tif (events!.length === 0) {\n\t\t\t\tdelete this._settingEvents[key];\n\t\t\t}\n\t\t});\n\t}\n\n\t// TODO code duplication with Properties\n\tpublic onPrivate<Key extends keyof this[\"_privateSettings\"]>(key: Key, callback: (value: this[\"_privateSettings\"][Key], target?: E, key?: Key) => void): IDisposer {\n\t\tthis._checkDisposed();\n\n\t\tlet events = this._privateSettingEvents[key];\n\n\t\tif (events === undefined) {\n\t\t\tevents = this._privateSettingEvents[key] = [];\n\t\t}\n\n\t\tevents.push(callback);\n\n\t\treturn new Disposer(() => {\n\t\t\t$array.removeFirst(events!, callback);\n\n\t\t\tif (events!.length === 0) {\n\t\t\t\tdelete this._privateSettingEvents[key];\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic _apply(entity: E, state: ApplyState<E>): IDisposer {\n\t\tthis._checkDisposed();\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$object.each(this._settingEvents, (key, events) => {\n\t\t\t$array.each(events, (event) => {\n\t\t\t\tdisposers.push(entity.on(key, event));\n\t\t\t});\n\t\t});\n\n\t\t$object.each(this._privateSettingEvents, (key, events) => {\n\t\t\t$array.each(events, (event) => {\n\t\t\t\tdisposers.push(entity.onPrivate(key, event));\n\t\t\t});\n\t\t});\n\n\t\tthis.states._apply(entity, state);\n\n\t\tdisposers.push(this.adapters._apply(entity));\n\t\tdisposers.push(entity.events.copyFrom(this.events));\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n\tpublic _setObjectTemplate(entity: E) {\n\t\tthis._checkDisposed();\n\t\tthis._entities.push(entity);\n\t}\n\n\tpublic _removeObjectTemplate(entity: E) {\n\t\t//this._checkDisposed();\n\t\t$array.remove(this._entities, entity);\n\t}\n\n\tpublic _stateChanged(name: string): void {\n\t\tthis._checkDisposed();\n\n\t\tthis._entities.forEach((entity) => {\n\t\t\tentity._applyStateByKey(name);\n\t\t});\n\t}\n}\n", "export type Order = -1 | 0 | 1;\n\n/**\n * @ignore\n */\nexport function compare<A extends string | number | boolean>(left: A, right: A): Order {\n\tif (left === right) {\n\t\treturn 0;\n\n\t} else if (left < right) {\n\t\treturn -1;\n\n\t} else {\n\t\treturn 1;\n\t}\n}\n\n/**\n * @ignore\n */\nexport function compareArray<A>(left: ArrayLike<A>, right: ArrayLike<A>, f: (x: A, y: A) => Order): Order {\n\tconst leftLength = left.length;\n\tconst rightLength = right.length;\n\n\tconst length = Math.min(leftLength, rightLength);\n\n\tfor (let i = 0; i < length; ++i) {\n\t\tconst order = f(left[i], right[i]);\n\n\t\tif (order !== 0) {\n\t\t\treturn order;\n\t\t}\n\t}\n\n\treturn compare(leftLength, rightLength);\n}\n\n/**\n * @ignore\n */\nexport function reverse(order: Order): Order {\n\tif (order < 0) {\n\t\treturn 1;\n\n\t} else if (order > 0) {\n\t\treturn -1;\n\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/**\n * @ignore\n */\nexport function compareNumber(a: number, b: number): Order {\n\tif (a === b) {\n\t\treturn 0;\n\n\t} else if (a < b) {\n\t\treturn -1;\n\n\t} else {\n\t\treturn 1;\n\t}\n}\n", "import type { Entity } from \"./util/Entity\";\nimport { Template } from \"./util/Template\";\nimport type { Root } from \"./Root\";\nimport type { IClasses } from \"./Classes\";\nimport * as $order from \"./util/Order\";\nimport * as $array from \"./util/Array\";\n\nexport interface IRule<A extends Entity> {\n\ttags: Array<string>;\n\ttemplate: Template<A>;\n}\n\n/**\n * A base class for an amCharts theme.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info\n * @important\n */\nexport class Theme {\n\n\tprotected _root!: Root;\n\n\t/**\n\t * Use this method to create an instance of this class.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\n\t * @param   root      Root element\n\t * @param   settings  Settings\n\t * @param   template  Template\n\t * @return            Instantiated object\n\t */\n\tstatic new<T extends typeof Theme>(this: T, root: Root): InstanceType<T> {\n\t\tconst x = (new this(root, true)) as InstanceType<T>;\n\t\tx.setupDefaultRules();\n\t\treturn x;\n\t}\n\n\tconstructor(root: Root, isReal:boolean) {\n\t\tthis._root = root;\n\t\tif (!isReal) {\n\t\t\tthrow new Error(\"You cannot use `new Class()`, instead use `Class.new()`\");\n\t\t}\n\t}\n\n\tprotected setupDefaultRules(): void {}\n\n\tprotected _rules: { [type: string]: Array<IRule<Entity>>; } = {};\n\n\t/**\n\t * Looks up the rules for a specific theme class.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info\n\t * @param   themeClass Theme class\n\t * @return             Array<IRule<A>>\n\t */\n\tpublic _lookupRules<A extends Entity>(themeClass: string): Array<IRule<A>> | undefined {\n\t\treturn this._rules[themeClass] as unknown as Array<IRule<A>> | undefined;\n\t}\n\n\t/**\n\t * Creates a [[Template]] for specific theme class and tags.\n\t *\n\t * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any\n\t * type checks.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info\n\t * @param   themeClass Theme class\n\t * @param   themeTags  Theme tags\n\t * @return             Template\n\t */\n\tpublic ruleRaw<A extends Entity>(themeClass: string, themeTags: Array<string> = []): Template<A> {\n\t\tlet rules = this._rules[themeClass];\n\n\t\tif (!rules) {\n\t\t\trules = this._rules[themeClass] = [];\n\t\t}\n\n\t\tthemeTags.sort($order.compare);\n\n\t\tconst { index, found } = $array.getSortedIndex(rules, (x) => {\n\t\t\tconst order = $order.compare(x.tags.length, themeTags.length);\n\n\t\t\tif (order === 0) {\n\t\t\t\treturn $order.compareArray(x.tags, themeTags, $order.compare);\n\n\t\t\t} else {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t});\n\n\t\tif (found) {\n\t\t\treturn rules[index].template as Template<A>;\n\n\t\t} else {\n\t\t\tconst template = Template.new<A>({});\n\n\t\t\trules.splice(index, 0, {\n\t\t\t\ttags: themeTags,\n\t\t\t\ttemplate,\n\t\t\t});\n\n\t\t\treturn template;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a [[Template]] for specific theme class and tags.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info\n\t * @param   themeClass Theme class\n\t * @param   themeTags  Theme tags\n\t * @return             Template\n\t */\n\tpublic rule<K extends keyof IClasses>(themeClass: K, themeTags: Array<string> = []): Template<IClasses[K]> {\n\t\treturn this.ruleRaw(themeClass, themeTags) as Template<IClasses[K]>;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["copy", "each", "eachContinue", "copy", "each", "eachContinue", "each", "state", "value"]
}
