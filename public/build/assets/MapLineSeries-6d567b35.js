import{h as X,n as _,j as C,s as M,k as Y,l as v,p as P,q as b,t as H,u as j,v as J,w as G,G as q,P as K,i as I,d as z,L as Q,T as U,e as A}from"./AnimatedTheme-60f9fbb6.js";var O,V,w,S,k={sphere:_,point:_,lineStart:W,lineEnd:_,polygonStart:_,polygonEnd:_};function W(){k.point=$,k.lineEnd=Z}function Z(){k.point=k.lineEnd=_}function $(u,e){u*=b,e*=b,V=u,w=v(e),S=P(e),k.point=ee}function ee(u,e){u*=b,e*=b;var t=v(e),i=P(e),n=H(u-V),s=P(n),a=v(n),l=i*a,r=S*t-w*i*s,p=w*t+S*i*s;O.add(C(M(l*l+r*r),p)),V=u,w=t,S=i}function F(u){return O=new Y,X(u,k),+O}var B=[null,null],te={type:"LineString",coordinates:B};function ie(u,e){return B[0]=u,B[1]=e,F(te)}function ne(u,e){var t=u[0]*b,i=u[1]*b,n=e[0]*b,s=e[1]*b,a=P(i),l=v(i),r=P(s),p=v(s),g=a*P(t),d=a*v(t),y=r*P(n),m=r*v(n),h=2*J(M(G(s-i)+a*r*G(n-t))),L=v(h),f=h?function(o){var c=v(o*=h)/L,D=v(h-o)/L,x=D*g+c*y,T=D*d+c*m,R=D*l+c*p;return[C(T,x)*j,C(R,M(x*x+T*T))*j]}:function(){return[t*j,i*j]};return f.distance=h,f}class N extends q{constructor(){super(...arguments),Object.defineProperty(this,"_projectionDirty",{enumerable:!0,configurable:!0,writable:!0,value:!1})}_beforeChanged(){if(super._beforeChanged(),this._projectionDirty||this.isDirty("geometry")||this.isDirty("precision")){const e=this.get("geometry");if(e){const i=this.getPrivate("series");if(i){const n=i.chart;if(n){const s=n.get("projection");let a=null;s&&s.clipAngle&&(a=s.clipAngle(),s.precision(this.get("precision",.5)));const l=this.dataItem,r=n.getPrivate("geoPath");if(r&&l)if(this._clear=!0,l.get("lineType",i.get("lineType"))=="straight"){const p=this.get("geometry");if(p){let g=p.coordinates;if(g){let d;p.type=="LineString"?d=[g]:p.type=="MultiLineString"&&(d=g),this.set("draw",y=>{for(let m=0;m<d.length;m++){let h=d[m];if(h.length>0){const L=h[0],f=n.convert({longitude:L[0],latitude:L[1]});y.lineTo(f.x,f.y);for(let o=0;o<h.length;o++){const c=h[o],D=n.convert({longitude:c[0],latitude:c[1]});y.lineTo(D.x,D.y)}}}})}}}else this.set("draw",p=>{s&&i.get("clipBack")===!1&&s.clipAngle(180),r.context(this._display),r(e),r.context(null),s&&s.clipAngle&&s.clipAngle(a)})}}}const t="linechanged";this.events.isEnabled(t)&&this.events.dispatch(t,{type:t,target:this})}}markDirtyProjection(){this.markDirty(),this._projectionDirty=!0}_clearDirty(){super._clearDirty(),this._projectionDirty=!1}_getTooltipPoint(){let e=this.get("tooltipX"),t=this.get("tooltipY"),i=0,n=0;if(I(e)&&(i=e),I(t)&&(n=t),e instanceof K){const s=this.positionToGeoPoint(e.value),a=this.getPrivate("series");if(a){const l=a.chart;if(l){const r=l.convert(s);i=r.x,n=r.y}}}return{x:i,y:n}}positionToGeoPoint(e){const t=this.get("geometry"),i=this.getPrivate("series"),n=i.chart,s=this.dataItem;if(t&&i&&n&&s){const a=s.get("lineType",i.get("lineType"));let l=F(t),r=0,p,g=0,d=0,y,m,h=t.coordinates;if(h){let L;t.type=="LineString"?L=[h]:t.type=="MultiLineString"&&(L=h);for(let f=0;f<L.length;f++){let o=L[f];if(o.length>1){for(let c=1;c<o.length;c++)if(y=o[c-1],m=o[c],g=r/l,p=ie(y,m),r+=p,d=r/l,g<=e&&d>e){f=L.length;break}}else o.length==1&&(y=o[0],m=o[0],g=0,d=1)}if(y&&m){let f=(e-g)/(d-g),o;if(a=="straight"){let c=n.convert({longitude:y[0],latitude:y[1]}),D=n.convert({longitude:m[0],latitude:m[1]}),x=c.x+(D.x-c.x)*f,T=c.y+(D.y-c.y)*f;return n.invert({x,y:T})}else return o=ne(y,m)(f),{longitude:o[0],latitude:o[1]}}}}return{longitude:0,latitude:0}}}Object.defineProperty(N,"className",{enumerable:!0,configurable:!0,writable:!0,value:"MapLine"});Object.defineProperty(N,"classNames",{enumerable:!0,configurable:!0,writable:!0,value:q.classNames.concat([N.className])});class E extends z{constructor(){super(...arguments),Object.defineProperty(this,"mapLines",{enumerable:!0,configurable:!0,writable:!0,value:new Q(U.new({}),()=>N._new(this._root,{},[this.mapLines.template]))}),Object.defineProperty(this,"_types",{enumerable:!0,configurable:!0,writable:!0,value:["LineString","MultiLineString"]})}_afterNew(){this.fields.push("lineType"),this._setRawDefault("lineTypeField","lineType"),super._afterNew()}makeMapLine(e){const t=this.children.push(this.mapLines.make());return t._setDataItem(e),this.mapLines.push(t),t}markDirtyProjection(){A(this.dataItems,e=>{let t=e.get("mapLine");t&&t.markDirtyProjection()})}_prepareChildren(){super._prepareChildren(),this.isDirty("stroke")&&this.mapLines.template.set("stroke",this.get("stroke"))}processDataItem(e){super.processDataItem(e);let t=e.get("mapLine");t||(t=this.makeMapLine(e)),this._handlePointsToConnect(e),e.on("pointsToConnect",()=>{this._handlePointsToConnect(e)}),e.set("mapLine",t),this._addGeometry(e.get("geometry"),this),t.setPrivate("series",this)}_handlePointsToConnect(e){const t=e.get("pointsToConnect");t&&(A(t,i=>{i.on("geometry",()=>{this.markDirtyValues(e)}),i.on("longitude",()=>{this.markDirtyValues(e)}),i.on("latitude",()=>{this.markDirtyValues(e)})}),this.markDirtyValues(e))}markDirtyValues(e){if(super.markDirtyValues(),e){const t=e.get("mapLine");if(t){const i=e.get("pointsToConnect");if(i){let n=[];A(i,a=>{const l=a.get("longitude"),r=a.get("latitude");if(l!=null&&r!=null)n.push([l,r]);else{const p=a.get("geometry");if(p){const g=p.coordinates;g&&n.push([g[0],g[1]])}}});let s={type:"LineString",coordinates:n};e.setRaw("geometry",s),t.set("geometry",s)}else t.set("geometry",e.get("geometry"))}}}disposeDataItem(e){super.disposeDataItem(e);const t=e.get("mapLine");t&&(this.mapLines.removeValue(t),t.dispose())}_excludeDataItem(e){super._excludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!1)}_unexcludeDataItem(e){super._unexcludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!0)}_notIncludeDataItem(e){super._notIncludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!1)}_unNotIncludeDataItem(e){super._unNotIncludeDataItem(e);const t=e.get("mapLine");t&&t.setPrivate("visible",!0)}}Object.defineProperty(E,"className",{enumerable:!0,configurable:!0,writable:!0,value:"MapLineSeries"});Object.defineProperty(E,"classNames",{enumerable:!0,configurable:!0,writable:!0,value:z.classNames.concat([E.className])});export{E as M};
